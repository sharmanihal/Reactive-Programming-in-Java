## 1\. The Problem: Synchronous Blocking

In traditional programming, when you call a method that performs a long-running task (like a network request or a database query), your program's execution **blocks**—it waits—until the task is finished. This is inefficient, especially in applications that need to handle many tasks concurrently.

Asynchronous programming solves this. You can start a task on a separate thread and your main thread can continue doing other work. The challenge is getting the result back from that task when it's done. This is where `Future` comes in.

-----

## 2\. The `Future` Interface: A Simple Promise

Introduced in Java 5, a `Future<V>` is an interface that represents the result of an asynchronous computation. Think of it as a **promise** or a **placeholder** for a value that will be available later.

When you submit a task to an `ExecutorService`, you don't get the result immediately. Instead, you get a `Future` object.

It's like ordering a coffee. You give your order (submit the task) and you get a receipt with an order number (the `Future`). You can go do other things, and when you're ready, you can use your receipt to claim your coffee (get the result).

### Key Methods of `Future`

A `Future` has a few core methods:

  * `V get()`: This is the most important method. It **waits (blocks)** until the computation is complete and then retrieves its result. This blocking nature is the primary limitation of `Future`.
  * `V get(long timeout, TimeUnit unit)`: A safer version of `get()`. It waits for a specified amount of time. If the result isn't ready by then, it throws a `TimeoutException`.
  * `boolean isDone()`: Checks if the task is complete. It returns `true` if the task finished normally, was cancelled, or threw an exception. This is useful for non-blocking checks.
  * `boolean isCancelled()`: Checks if the task was cancelled before it completed normally.
  * `boolean cancel(boolean mayInterruptIfRunning)`: Attempts to cancel the execution of this task.

### Example: Using `Future` with `ExecutorService`

Here’s a typical use case. We create a thread pool and submit a task that simulates a long-running operation.

```java
import java.util.concurrent.*;

public class FutureExample {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        // Create a thread pool with one thread
        ExecutorService executor = Executors.newSingleThreadExecutor();

        // Submit a task that returns a String after a 2-second delay
        System.out.println("Submitting a task to calculate a complex result...");
        Future<String> futureResult = executor.submit(() -> {
            Thread.sleep(2000); // Simulate long work
            return "Hello, from the Future!";
        });

        System.out.println("Task submitted. Main thread is doing other work...");
        // The main thread can do other things here while the task runs...
        // For example, we can check if the task is done without blocking.
        while (!futureResult.isDone()) {
            System.out.println("Task is not done yet. Waiting...");
            Thread.sleep(500);
        }

        // Now, block and get the result.
        // Since we looped with isDone(), this call will return immediately.
        String result = futureResult.get();
        System.out.println("Result received: " + result);

        executor.shutdown();
    }
}
```

### Limitations of `Future` ⚠️

While useful, `Future` is quite limited:

1.  **It's Blocking:** You cannot get the result without calling `get()`, which blocks your thread. The primary goal of asynchronicity is to *avoid* blocking, making `Future` somewhat counterintuitive.
2.  **No Chaining:** You cannot chain actions. There's no way to say, "When this task is done, *then* do this next thing with the result," without more blocking `get()` calls.
3.  **No Manual Completion:** You can't manually complete a `Future` with a result. It can only be completed by the asynchronous task itself.
4.  **Poor Exception Handling:** Exception handling is clumsy. You have to wrap the `get()` call in a `try-catch` block.

-----

## 3\. `CompletableFuture`: The Powerful Evolution

Introduced in Java 8, `CompletableFuture<T>` is a massive improvement. It implements both the `Future` and `CompletionStage` interfaces.

  * As a `Future`, it maintains backward compatibility.
  * As a `CompletionStage`, it provides a powerful, fluent API for **composing, combining, and processing** asynchronous tasks in a non-blocking way.

Think of it as an advanced "coffee order." Not only do you get a receipt, but the barista can also text you when it's ready (a callback), or you can tell them, "Once the espresso shot is pulled, *then* add steamed milk to it" (chaining actions).

### Creating a `CompletableFuture`

You typically create one in two ways for running an asynchronous task:

1.  **`runAsync(Runnable runnable)`**: Use this if your task doesn't return a value. It returns a `CompletableFuture<Void>`.
2.  **`supplyAsync(Supplier<T> supplier)`**: Use this if your task returns a value. It returns a `CompletableFuture<T>`.

Both methods have an overloaded version that accepts an `Executor`, allowing you to specify your own thread pool. If you don't provide one, they use the default `ForkJoinPool.commonPool()`.

```java
// Task that doesn't return a value
CompletableFuture<Void> futureRun = CompletableFuture.runAsync(() -> {
    System.out.println("Running a task in the background.");
});

// Task that returns a value
CompletableFuture<String> futureSupply = CompletableFuture.supplyAsync(() -> {
    // Simulate fetching data
    return "Here is the fetched data!";
});
```

-----

## 4\. Processing Results: Callbacks (The `then...` Family)

This is where `CompletableFuture` shines. Instead of blocking with `get()`, you attach a **callback** that will be executed automatically when the result is ready.

### `thenApply()` - Transform the Result

Use `thenApply(Function<T, U> fn)` when you want to take the result of a `CompletableFuture`, transform it, and return a new `CompletableFuture` with the transformed result.

  * **Input:** A function (`T -> U`).
  * **Output:** A `CompletableFuture<U>`.

<!-- end list -->

```java
CompletableFuture<String> initialFuture = CompletableFuture.supplyAsync(() -> "123");

CompletableFuture<Integer> transformedFuture = initialFuture.thenApply(s -> Integer.parseInt(s));

// When the transformedFuture completes, the result will be the integer 123.
System.out.println(transformedFuture.get()); // Prints 123
```

**How it works:** `thenApply` registers a callback. When `initialFuture` completes with the string `"123"`, the JVM automatically passes that string to the lambda function `s -> Integer.parseInt(s)`. The result of that function (the integer `123`) is used to complete `transformedFuture`.

### `thenAccept()` - Consume the Result

Use `thenAccept(Consumer<T> action)` when you are at the end of the chain and just want to *do something* with the result. It does not return a value.

  * **Input:** A consumer (`T -> void`).
  * **Output:** A `CompletableFuture<Void>`.

<!-- end list -->

```java
CompletableFuture<String> userFuture = CompletableFuture.supplyAsync(() -> "Alice");

CompletableFuture<Void> processingFuture = userFuture.thenAccept(name -> {
    System.out.println("Hello, " + name); // Action to perform
});

// The main thread can continue. "Hello, Alice" will print when userFuture completes.
```

### `thenRun()` - Run an Action

Use `thenRun(Runnable action)` when you don't care about the result of the previous stage but want to run some code after it completes.

  * **Input:** A runnable (`() -> void`).
  * **Output:** A `CompletableFuture<Void>`.

<!-- end list -->

```java
CompletableFuture<Void> notificationFuture = CompletableFuture.supplyAsync(() -> "Email sent successfully")
        .thenRun(() -> {
            System.out.println("Logging action: Notification task completed.");
        });
```

### A Note on Threads: `...` vs `...Async`

Each of the `then...` methods has an `...Async` variant (e.g., `thenApplyAsync`).

  * `thenApply()`: The supplied function will be executed in the **same thread** that completed the previous stage, or in the thread that is attaching the callback if the future is already complete.
  * `thenApplyAsync()`: The supplied function is guaranteed to be executed in a **different thread** from the `ForkJoinPool.commonPool()` (or a custom executor if provided).

**When to use `...Async`?** Use it when the task in your callback is itself a long-running, blocking operation, to avoid stalling the pipeline.

-----

## 5\. Combining Futures

`CompletableFuture` provides powerful ways to orchestrate multiple asynchronous tasks.

### `thenCompose()` - Chaining Dependent Futures

Use `thenCompose(Function<T, CompletionStage<U>> fn)` when the next asynchronous operation **depends on the result of the first one**. It's for creating a sequential pipeline.

This is similar to `flatMap` in streams. It avoids nested futures like `CompletableFuture<CompletableFuture<User>>`.

  * **Scenario:** Get a user ID, then use that ID to fetch the user's details.

<!-- end list -->

```java
CompletableFuture<String> userIdFuture = CompletableFuture.supplyAsync(() -> "user-123");

// WRONG WAY with thenApply: returns a nested future
CompletableFuture<CompletableFuture<String>> nestedFuture =
        userIdFuture.thenApply(id -> getUserDetails(id));

// RIGHT WAY with thenCompose: returns a clean, single future
CompletableFuture<String> userDetailsFuture =
        userIdFuture.thenCompose(id -> getUserDetails(id));

System.out.println(userDetailsFuture.get()); // Prints "Details for user-123"

// Helper method that returns a CompletableFuture
public static CompletableFuture<String> getUserDetails(String userId) {
    return CompletableFuture.supplyAsync(() -> "Details for " + userId);
}
```

### `thenCombine()` - Combining Independent Futures

Use `thenCombine(CompletionStage<U> other, BiFunction<T, U, V> fn)` when you have two **independent** futures and want to do something with both of their results once they are *both* complete.

  * **Scenario:** Fetch a product's price and its shipping cost from two different services, then combine them to get the total cost.

<!-- end list -->

```java
CompletableFuture<Double> priceFuture = CompletableFuture.supplyAsync(() -> 20.00);
CompletableFuture<Double> shippingFuture = CompletableFuture.supplyAsync(() -> 5.50);

CompletableFuture<Double> totalFuture = priceFuture.thenCombine(
    shippingFuture,
    (price, shipping) -> price + shipping // BiFunction to combine results
);

System.out.println("Total price: " + totalFuture.get()); // Prints 25.5
```

### `allOf()` and `anyOf()` - Working with Many Futures

  * `CompletableFuture.allOf(CompletableFuture<?>... cfs)`: Returns a `CompletableFuture<Void>` that completes only when **all** of the given futures have completed. It's useful for waiting for a batch of independent tasks to finish.
  * `CompletableFuture.anyOf(CompletableFuture<?>... cfs)`: Returns a `CompletableFuture<Object>` that completes as soon as **any one** of the given futures completes, with the same result.

<!-- end list -->

```java
// Example with allOf
CompletableFuture<String> f1 = CompletableFuture.supplyAsync(() -> "Task 1");
CompletableFuture<String> f2 = CompletableFuture.supplyAsync(() -> "Task 2");
CompletableFuture<String> f3 = CompletableFuture.supplyAsync(() -> "Task 3");

CompletableFuture<Void> allFutures = CompletableFuture.allOf(f1, f2, f3);

// This will block until f1, f2, and f3 are all done.
allFutures.get();

System.out.println("All tasks are finished.");
// To get the results, you must get them from the original futures.
System.out.println(f1.get()); // isDone() is true, so this won't block
```

-----

## 6\. Exception Handling

Robust asynchronous code requires proper exception handling.

### `exceptionally()` - The `catch` Block

Use `exceptionally(Function<Throwable, T> fn)` to provide a recovery mechanism. If the original future completes with an exception, this function is triggered, allowing you to provide a default or alternative value.

```java
CompletableFuture<String> faultyFuture = CompletableFuture.supplyAsync(() -> {
    if (true) { // Simulate an error condition
        throw new RuntimeException("Oops! Something went wrong.");
    }
    return "Success!";
}).exceptionally(ex -> {
    System.err.println("Caught exception: " + ex.getMessage());
    return "Default Value"; // Provide a fallback result
});

System.out.println("Result: " + faultyFuture.get()); // Prints "Result: Default Value"
```

### `handle()` - The `finally` Block

Use `handle(BiFunction<T, Throwable, U> fn)` to process the outcome, regardless of whether it was a success or a failure. It receives both the result (which will be `null` on failure) and the exception (which will be `null` on success). It *always* executes.

```java
CompletableFuture<String> future = CompletableFuture.supplyAsync(() -> {
    // Uncomment the next line to simulate failure
    // if (true) throw new RuntimeException("Failure!");
    return "Success";
}).handle((result, ex) -> {
    if (ex != null) {
        System.out.println("Operation failed with: " + ex.getMessage());
        return "Recovered";
    }
    System.out.println("Operation succeeded with: " + result);
    return "Handled";
});

System.out.println(future.get());
```

-----

## 7\. Summary: `Future` vs. `CompletableFuture`

| Feature | `Future` (Java 5) | `CompletableFuture` (Java 8) |
| :--- | :--- | :--- |
| **Getting Result** | Blocking `get()` | Non-blocking via callbacks (`thenApply`, etc.) |
| **Chaining Tasks** | No | Yes (`thenCompose`, `thenApply`) |
| **Combining Tasks**| No | Yes (`thenCombine`) |
| **Multiple Futures**| No built-in support | Yes (`allOf`, `anyOf`) |
| **Error Handling** | `try-catch` around `get()` | Fluent API (`exceptionally`, `handle`) |
| **Manual Completion**| No | Yes (`complete()`, `completeExceptionally()`) |
