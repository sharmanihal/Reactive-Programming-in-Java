`WebClient` is the modern, non-blocking, and reactive web client in Spring Framework 5 and Spring Boot 2.x and later. It's the recommended replacement for the older, synchronous `RestTemplate`. It's built on top of Project Reactor, which provides the reactive stream types `Mono` (for 0 or 1 item) and `Flux` (for 0 to N items).

**Key characteristics:**

  * **Non-Blocking:** It doesn't block the calling thread while waiting for a response, making it highly efficient for handling concurrent requests with a small number of threads.
  * **Reactive:** It uses a functional and declarative API to build elegant and readable request/response pipelines.
  * **Asynchronous:** Operations are handled asynchronously, improving application throughput and scalability.

-----

## Setting Up `WebClient`

To use `WebClient`, you need the `spring-boot-starter-webflux` dependency in your project. This starter includes Project Reactor and the Netty server, which `WebClient` uses by default.

**Maven (`pom.xml`):**

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-webflux</artifactId>
</dependency>
```

**Gradle (`build.gradle`):**

```groovy
implementation 'org.springframework.boot:spring-boot-starter-webflux'
```

### Creating a `WebClient` Instance

The best practice is to configure a `WebClient.Builder` bean in a `@Configuration` class and inject it wherever you need to make calls. This allows for centralized configuration (base URL, default headers, etc.) and easy testing.

**1. Basic Configuration:**
This creates a reusable `WebClient` instance.

```java
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.reactive.function.client.WebClient;

@Configuration
public class WebClientConfig {

    @Bean
    public WebClient webClient() {
        return WebClient.builder()
                .baseUrl("https://api.example.com") // Set a base URL for all requests
                .defaultHeader("Content-Type", "application/json")
                .build();
    }
}
```

**2. Injecting and Using It:**
You can then autowire this `WebClient` bean in your services.

```java
import org.springframework.stereotype.Service;
import org.springframework.beans.factory.annotation.Autowired;

@Service
public class MyApiService {

    private final WebClient webClient;

    @Autowired
    public MyApiService(WebClient webClient) {
        this.webClient = webClient;
    }

    // Methods to make API calls will go here
}
```

-----

## Core Components and Workflow

Making a request with `WebClient` follows a fluent, chainable API pattern. The workflow can be broken down into these steps:

1.  **Specify HTTP Method:** Start by choosing the HTTP verb (`GET`, `POST`, etc.).
2.  **Set URI:** Define the endpoint you want to call.
3.  **Set Headers/Cookies (Optional):** Add any necessary headers or cookies.
4.  **Set Request Body (for `POST`, `PUT`, `PATCH`):** Provide the payload to be sent.
5.  **Execute the Request:** Use `retrieve()` or `exchangeToMono()` / `exchangeToFlux()` to send the request.
6.  **Process the Response:** Define how to handle the response body and potential errors.
7.  **Subscribe:** The request is only sent when something "subscribes" to the resulting `Mono` or `Flux`.

### 1\. HTTP Method and URI

You begin a request chain by specifying the method.

  * `webClient.get()`
  * `webClient.post()`
  * `webClient.put()`
  * `webClient.delete()`
  * `webClient.patch()`
  * `webClient.head()`
  * `webClient.options()`

After the method, you specify the URI using `.uri()`. You can use a template with path variables.

```java
// GET request to /users/123
webClient.get()
         .uri("/users/{id}", 123)
         // ... rest of the chain
```

### 2\. Headers and Body

You can easily add headers, content type, and a request body.

  * `.header(name, value)`: Adds a single header.
  * `.headers(headersConsumer)`: Adds multiple headers.
  * `.contentType(MediaType)`: Sets the `Content-Type` header.
  * `.accept(MediaType)`: Sets the `Accept` header.
  * `.bodyValue(object)`: A shortcut for sending a simple object as the body.
  * `.body(BodyInserter)`: A more powerful way to provide the body, often from a reactive stream (`Publisher`).

<!-- end list -->

```java
User newUser = new User("john.doe", "john.doe@example.com");

webClient.post()
         .uri("/users")
         .contentType(MediaType.APPLICATION_JSON)
         .bodyValue(newUser) // Simple way to send an object
         // ... or use a BodyInserter for more complex scenarios
         // .body(BodyInserters.fromValue(newUser))
         // ... rest of the chain
```

### 3\. Executing the Request: `retrieve()` vs. `exchange()`

This is a crucial step. You have two main methods to execute the request:

  * **`.retrieve()`:** The simplest and most common method. It's great for straightforward cases where you just need the response body. It automatically checks for `4xx` (client) and `5xx` (server) error status codes and throws a `WebClientResponseException` if one occurs.

  * **`.exchangeToMono()` or `.exchangeToFlux()` (formerly `.exchange()`):** This is a lower-level, more powerful method. It gives you full control over the entire `ClientResponse`, including the status code, headers, and the body. You are responsible for handling error status codes yourself. **You must always consume the response body when using this method to avoid memory leaks.**

| Feature | `.retrieve()` | `.exchangeToMono()` / `.exchangeToFlux()` |
| :--- | :--- | :--- |
| **Use Case** | Most common scenarios; when you primarily need the body. | When you need to inspect response headers or status codes before deciding how to process the body. |
| **Error Handling** | Automatic for 4xx/5xx statuses. | Manual. You must check the status code and handle it. |
| **Simplicity** | High. Very easy to use. | Lower. Requires more boilerplate code. |
| **Control** | Less control over the `ClientResponse`. | Full control over the `ClientResponse`. |

### 4\. Processing the Response Body

After executing the request, you define how to convert the response body into a specific type using:

  * **`.bodyToMono(Class<T>)`**: To convert the response body into a `Mono` of a specific class (for single objects).
  * **`.bodyToFlux(Class<T>)`**: To convert the response body into a `Flux` of a specific class (for lists or streams of objects).

<!-- end list -->

```java
// Using retrieve()
Mono<User> userMono = webClient.get()
    .uri("/users/{id}", 1)
    .retrieve()
    .bodyToMono(User.class);

// Using exchangeToMono()
Mono<User> userMonoFromExchange = webClient.get()
    .uri("/users/{id}", 1)
    .exchangeToMono(response -> {
        if (response.statusCode().is2xxSuccessful()) {
            return response.bodyToMono(User.class);
        } else {
            // Handle error response
            return Mono.error(new MyCustomException("API call failed"));
        }
    });
```

-----

## Practical Code Examples

Let's assume we have a simple `Post` DTO:

```java
class Post {
    private Integer id;
    private Integer userId;
    private String title;
    private String body;
    // Getters and Setters
}
```

### GET: Fetching a Single Object (`Mono`)

This example fetches a single post by its ID. The result is a `Mono<Post>`.

```java
public Mono<Post> getPostById(int id) {
    return this.webClient.get()
        .uri("/posts/{id}", id)
        .retrieve()
        .bodyToMono(Post.class);
}
```

### GET: Fetching a List of Objects (`Flux`)

This example fetches all posts. The result is a `Flux<Post>`.

```java
public Flux<Post> getAllPosts() {
    return this.webClient.get()
        .uri("/posts")
        .retrieve()
        .bodyToFlux(Post.class);
}
```

### POST: Creating a New Object

This example creates a new post by sending a `Post` object in the request body.

```java
public Mono<Post> createPost(Post newPost) {
    return this.webClient.post()
        .uri("/posts")
        .bodyValue(newPost)
        .retrieve()
        .bodyToMono(Post.class);
}
```

### PUT: Updating an Object

This example updates an existing post.

```java
public Mono<Post> updatePost(int id, Post updatedPost) {
    return this.webClient.put()
        .uri("/posts/{id}", id)
        .bodyValue(updatedPost)
        .retrieve()
        .bodyToMono(Post.class);
}
```

### DELETE: Removing an Object

This example deletes a post and expects an empty response (`Mono<Void>`).

```java
public Mono<Void> deletePost(int id) {
    return this.webClient.delete()
        .uri("/posts/{id}", id)
        .retrieve()
        .bodyToMono(Void.class); // Use Void.class for empty responses
}
```

-----

## Advanced Error Handling

While `.retrieve()` handles errors automatically, you might want custom logic. The `.onStatus()` operator lets you inspect the HTTP status and react accordingly.

This is useful for mapping specific HTTP error codes to custom exceptions in your application.

```java
import org.springframework.http.HttpStatus;
import reactor.core.publisher.Mono;

public Mono<Post> getPostWithCustomErrorHandling(int id) {
    return this.webClient.get()
        .uri("/posts/{id}", id)
        .retrieve()
        .onStatus(HttpStatus::is4xxClientError, response ->
            Mono.error(new PostNotFoundException("Post not found with ID: " + id))
        )
        .onStatus(HttpStatus::is5xxServerError, response ->
            Mono.error(new ServerApiException("Server error during API call"))
        )
        .bodyToMono(Post.class);
}

// Custom exception classes
class PostNotFoundException extends RuntimeException {
    public PostNotFoundException(String message) { super(message); }
}

class ServerApiException extends RuntimeException {
    public ServerApiException(String message) { super(message); }
}
```

-----

## Synchronous (Blocking) Usage

Although `WebClient` is designed for non-blocking, reactive applications, you can use it in a traditional synchronous application by calling the `.block()` method on the `Mono` or `Flux`.

⚠️ **Warning:** Using `.block()` defeats the purpose of non-blocking I/O. It will block the current thread until the response is received. **Never use `.block()` in a reactive context (e.g., inside a Spring WebFlux controller)**, as it can lead to deadlocks and performance degradation. Use it only when you must bridge a reactive flow into a legacy blocking part of your application.

```java
public Post getPostSynchronously(int id) {
    try {
        // Block for a maximum of 5 seconds
        Post post = this.webClient.get()
            .uri("/posts/{id}", id)
            .retrieve()
            .bodyToMono(Post.class)
            .block(Duration.ofSeconds(5));
        return post;
    } catch (Exception e) {
        // Handle exceptions, including timeout
        log.error("Error fetching post synchronously", e);
        return null;
    }
}
```
